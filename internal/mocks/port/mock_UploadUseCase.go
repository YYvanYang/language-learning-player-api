// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	mock "github.com/stretchr/testify/mock"
	"github.com/yvanyang/language-learning-player-api/internal/domain"
	"github.com/yvanyang/language-learning-player-api/internal/port"
)

// NewMockUploadUseCase creates a new instance of MockUploadUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUploadUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUploadUseCase {
	mock := &MockUploadUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUploadUseCase is an autogenerated mock type for the UploadUseCase type
type MockUploadUseCase struct {
	mock.Mock
}

type MockUploadUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUploadUseCase) EXPECT() *MockUploadUseCase_Expecter {
	return &MockUploadUseCase_Expecter{mock: &_m.Mock}
}

// CompleteBatchUpload provides a mock function for the type MockUploadUseCase
func (_mock *MockUploadUseCase) CompleteBatchUpload(ctx context.Context, userID domain.UserID, req port.BatchCompleteInput) ([]port.BatchCompleteResultItem, error) {
	ret := _mock.Called(ctx, userID, req)

	if len(ret) == 0 {
		panic("no return value specified for CompleteBatchUpload")
	}

	var r0 []port.BatchCompleteResultItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, port.BatchCompleteInput) ([]port.BatchCompleteResultItem, error)); ok {
		return returnFunc(ctx, userID, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, port.BatchCompleteInput) []port.BatchCompleteResultItem); ok {
		r0 = returnFunc(ctx, userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]port.BatchCompleteResultItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.UserID, port.BatchCompleteInput) error); ok {
		r1 = returnFunc(ctx, userID, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUploadUseCase_CompleteBatchUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteBatchUpload'
type MockUploadUseCase_CompleteBatchUpload_Call struct {
	*mock.Call
}

// CompleteBatchUpload is a helper method to define mock.On call
//   - ctx
//   - userID
//   - req
func (_e *MockUploadUseCase_Expecter) CompleteBatchUpload(ctx interface{}, userID interface{}, req interface{}) *MockUploadUseCase_CompleteBatchUpload_Call {
	return &MockUploadUseCase_CompleteBatchUpload_Call{Call: _e.mock.On("CompleteBatchUpload", ctx, userID, req)}
}

func (_c *MockUploadUseCase_CompleteBatchUpload_Call) Run(run func(ctx context.Context, userID domain.UserID, req port.BatchCompleteInput)) *MockUploadUseCase_CompleteBatchUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(domain.UserID), args[2].(port.BatchCompleteInput))
	})
	return _c
}

func (_c *MockUploadUseCase_CompleteBatchUpload_Call) Return(batchCompleteResultItems []port.BatchCompleteResultItem, err error) *MockUploadUseCase_CompleteBatchUpload_Call {
	_c.Call.Return(batchCompleteResultItems, err)
	return _c
}

func (_c *MockUploadUseCase_CompleteBatchUpload_Call) RunAndReturn(run func(ctx context.Context, userID domain.UserID, req port.BatchCompleteInput) ([]port.BatchCompleteResultItem, error)) *MockUploadUseCase_CompleteBatchUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteUpload provides a mock function for the type MockUploadUseCase
func (_mock *MockUploadUseCase) CompleteUpload(ctx context.Context, userID domain.UserID, req port.CompleteUploadInput) (*domain.AudioTrack, error) {
	ret := _mock.Called(ctx, userID, req)

	if len(ret) == 0 {
		panic("no return value specified for CompleteUpload")
	}

	var r0 *domain.AudioTrack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, port.CompleteUploadInput) (*domain.AudioTrack, error)); ok {
		return returnFunc(ctx, userID, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, port.CompleteUploadInput) *domain.AudioTrack); ok {
		r0 = returnFunc(ctx, userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.AudioTrack)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.UserID, port.CompleteUploadInput) error); ok {
		r1 = returnFunc(ctx, userID, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUploadUseCase_CompleteUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteUpload'
type MockUploadUseCase_CompleteUpload_Call struct {
	*mock.Call
}

// CompleteUpload is a helper method to define mock.On call
//   - ctx
//   - userID
//   - req
func (_e *MockUploadUseCase_Expecter) CompleteUpload(ctx interface{}, userID interface{}, req interface{}) *MockUploadUseCase_CompleteUpload_Call {
	return &MockUploadUseCase_CompleteUpload_Call{Call: _e.mock.On("CompleteUpload", ctx, userID, req)}
}

func (_c *MockUploadUseCase_CompleteUpload_Call) Run(run func(ctx context.Context, userID domain.UserID, req port.CompleteUploadInput)) *MockUploadUseCase_CompleteUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(domain.UserID), args[2].(port.CompleteUploadInput))
	})
	return _c
}

func (_c *MockUploadUseCase_CompleteUpload_Call) Return(audioTrack *domain.AudioTrack, err error) *MockUploadUseCase_CompleteUpload_Call {
	_c.Call.Return(audioTrack, err)
	return _c
}

func (_c *MockUploadUseCase_CompleteUpload_Call) RunAndReturn(run func(ctx context.Context, userID domain.UserID, req port.CompleteUploadInput) (*domain.AudioTrack, error)) *MockUploadUseCase_CompleteUpload_Call {
	_c.Call.Return(run)
	return _c
}

// RequestBatchUpload provides a mock function for the type MockUploadUseCase
func (_mock *MockUploadUseCase) RequestBatchUpload(ctx context.Context, userID domain.UserID, req port.BatchRequestUploadInput) ([]port.BatchURLResultItem, error) {
	ret := _mock.Called(ctx, userID, req)

	if len(ret) == 0 {
		panic("no return value specified for RequestBatchUpload")
	}

	var r0 []port.BatchURLResultItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, port.BatchRequestUploadInput) ([]port.BatchURLResultItem, error)); ok {
		return returnFunc(ctx, userID, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, port.BatchRequestUploadInput) []port.BatchURLResultItem); ok {
		r0 = returnFunc(ctx, userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]port.BatchURLResultItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.UserID, port.BatchRequestUploadInput) error); ok {
		r1 = returnFunc(ctx, userID, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUploadUseCase_RequestBatchUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestBatchUpload'
type MockUploadUseCase_RequestBatchUpload_Call struct {
	*mock.Call
}

// RequestBatchUpload is a helper method to define mock.On call
//   - ctx
//   - userID
//   - req
func (_e *MockUploadUseCase_Expecter) RequestBatchUpload(ctx interface{}, userID interface{}, req interface{}) *MockUploadUseCase_RequestBatchUpload_Call {
	return &MockUploadUseCase_RequestBatchUpload_Call{Call: _e.mock.On("RequestBatchUpload", ctx, userID, req)}
}

func (_c *MockUploadUseCase_RequestBatchUpload_Call) Run(run func(ctx context.Context, userID domain.UserID, req port.BatchRequestUploadInput)) *MockUploadUseCase_RequestBatchUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(domain.UserID), args[2].(port.BatchRequestUploadInput))
	})
	return _c
}

func (_c *MockUploadUseCase_RequestBatchUpload_Call) Return(batchURLResultItems []port.BatchURLResultItem, err error) *MockUploadUseCase_RequestBatchUpload_Call {
	_c.Call.Return(batchURLResultItems, err)
	return _c
}

func (_c *MockUploadUseCase_RequestBatchUpload_Call) RunAndReturn(run func(ctx context.Context, userID domain.UserID, req port.BatchRequestUploadInput) ([]port.BatchURLResultItem, error)) *MockUploadUseCase_RequestBatchUpload_Call {
	_c.Call.Return(run)
	return _c
}

// RequestUpload provides a mock function for the type MockUploadUseCase
func (_mock *MockUploadUseCase) RequestUpload(ctx context.Context, userID domain.UserID, filename string, contentType string) (*port.RequestUploadResult, error) {
	ret := _mock.Called(ctx, userID, filename, contentType)

	if len(ret) == 0 {
		panic("no return value specified for RequestUpload")
	}

	var r0 *port.RequestUploadResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, string, string) (*port.RequestUploadResult, error)); ok {
		return returnFunc(ctx, userID, filename, contentType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.UserID, string, string) *port.RequestUploadResult); ok {
		r0 = returnFunc(ctx, userID, filename, contentType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*port.RequestUploadResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.UserID, string, string) error); ok {
		r1 = returnFunc(ctx, userID, filename, contentType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUploadUseCase_RequestUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestUpload'
type MockUploadUseCase_RequestUpload_Call struct {
	*mock.Call
}

// RequestUpload is a helper method to define mock.On call
//   - ctx
//   - userID
//   - filename
//   - contentType
func (_e *MockUploadUseCase_Expecter) RequestUpload(ctx interface{}, userID interface{}, filename interface{}, contentType interface{}) *MockUploadUseCase_RequestUpload_Call {
	return &MockUploadUseCase_RequestUpload_Call{Call: _e.mock.On("RequestUpload", ctx, userID, filename, contentType)}
}

func (_c *MockUploadUseCase_RequestUpload_Call) Run(run func(ctx context.Context, userID domain.UserID, filename string, contentType string)) *MockUploadUseCase_RequestUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(domain.UserID), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUploadUseCase_RequestUpload_Call) Return(requestUploadResult *port.RequestUploadResult, err error) *MockUploadUseCase_RequestUpload_Call {
	_c.Call.Return(requestUploadResult, err)
	return _c
}

func (_c *MockUploadUseCase_RequestUpload_Call) RunAndReturn(run func(ctx context.Context, userID domain.UserID, filename string, contentType string) (*port.RequestUploadResult, error)) *MockUploadUseCase_RequestUpload_Call {
	_c.Call.Return(run)
	return _c
}
