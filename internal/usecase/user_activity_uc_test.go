// internal/usecase/user_activity_uc_test.go
package usecase_test

import (
	"context"
	"testing"
	"time"

	"github.com/yvanyang/language-learning-player-backend/internal/domain"
	"github.com/yvanyang/language-learning-player-backend/internal/port"
	"github.com/yvanyang/language-learning-player-backend/internal/port/mocks"
	"github.com/yvanyang/language-learning-player-backend/internal/usecase"
    "io" // For discarding logs
	"log/slog"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// Re-use test helpers if defined in another _test file in the same package,
// otherwise, redefine or move to a shared test utility package.
func newTestLogger() *slog.Logger {
     return slog.New(slog.NewTextHandler(io.Discard, nil))
}

func TestUserActivityUseCase_RecordPlaybackProgress_Success(t *testing.T) {
	mockProgressRepo := mocks.NewMockPlaybackProgressRepository(t)
	mockBookmarkRepo := mocks.NewMockBookmarkRepository(t) // Needed for constructor
	mockTrackRepo := mocks.NewMockAudioTrackRepository(t)
	logger := newTestLogger()

	uc := usecase.NewUserActivityUseCase(mockProgressRepo, mockBookmarkRepo, mockTrackRepo, logger)

	userID := domain.NewUserID()
	trackID := domain.NewTrackID()
	progress := 30 * time.Second

	// Expect TrackRepo.Exists to be called and return true
	mockTrackRepo.On("Exists", mock.Anything, trackID).Return(true, nil).Once()

	// Expect ProgressRepo.Upsert to be called
	mockProgressRepo.On("Upsert", mock.Anything, mock.MatchedBy(func(p *domain.PlaybackProgress) bool {
		return p.UserID == userID && p.TrackID == trackID && p.Progress == progress
	})).Return(nil).Once()

	// Execute
	err := uc.RecordPlaybackProgress(context.Background(), userID, trackID, progress)

	// Assert
	require.NoError(t, err)
	mockTrackRepo.AssertExpectations(t)
	mockProgressRepo.AssertExpectations(t)
}

func TestUserActivityUseCase_RecordPlaybackProgress_TrackNotFound(t *testing.T) {
	mockProgressRepo := mocks.NewMockPlaybackProgressRepository(t)
	mockBookmarkRepo := mocks.NewMockBookmarkRepository(t)
	mockTrackRepo := mocks.NewMockAudioTrackRepository(t)
	logger := newTestLogger()
	uc := usecase.NewUserActivityUseCase(mockProgressRepo, mockBookmarkRepo, mockTrackRepo, logger)

	userID := domain.NewUserID()
	trackID := domain.NewTrackID()
	progress := 30 * time.Second

	// Expect TrackRepo.Exists to return false
	mockTrackRepo.On("Exists", mock.Anything, trackID).Return(false, nil).Once()

	// Execute
	err := uc.RecordPlaybackProgress(context.Background(), userID, trackID, progress)

	// Assert
	require.Error(t, err)
	assert.ErrorIs(t, err, domain.ErrNotFound) // Expect NotFound because track doesn't exist

	mockTrackRepo.AssertExpectations(t)
	// Ensure Upsert was not called
	mockProgressRepo.AssertNotCalled(t, "Upsert", mock.Anything, mock.Anything)
}

func TestUserActivityUseCase_CreateBookmark_Success(t *testing.T) {
	mockProgressRepo := mocks.NewMockPlaybackProgressRepository(t)
	mockBookmarkRepo := mocks.NewMockBookmarkRepository(t)
	mockTrackRepo := mocks.NewMockAudioTrackRepository(t)
	logger := newTestLogger()
	uc := usecase.NewUserActivityUseCase(mockProgressRepo, mockBookmarkRepo, mockTrackRepo, logger)

	userID := domain.NewUserID()
	trackID := domain.NewTrackID()
	timestamp := 60 * time.Second
	note := "Important point"

	// Expect TrackRepo.Exists to return true
	mockTrackRepo.On("Exists", mock.Anything, trackID).Return(true, nil).Once()

	// Expect BookmarkRepo.Create to be called
	// We capture the bookmark to check its details
	var createdBookmark *domain.Bookmark
	mockBookmarkRepo.On("Create", mock.Anything, mock.MatchedBy(func(b *domain.Bookmark) bool {
		createdBookmark = b
		return b.UserID == userID && b.TrackID == trackID && b.Timestamp == timestamp && b.Note == note
	})).Return(nil).Once()


	// Execute
	bookmark, err := uc.CreateBookmark(context.Background(), userID, trackID, timestamp, note)

	// Assert
	require.NoError(t, err)
	require.NotNil(t, bookmark)
	// Check if the returned bookmark matches the one captured (or has expected fields)
	assert.Equal(t, createdBookmark.ID, bookmark.ID) // ID is generated by domain/repo
	assert.Equal(t, userID, bookmark.UserID)
	assert.Equal(t, trackID, bookmark.TrackID)
	assert.Equal(t, timestamp, bookmark.Timestamp)
	assert.Equal(t, note, bookmark.Note)

	mockTrackRepo.AssertExpectations(t)
	mockBookmarkRepo.AssertExpectations(t)
}

func TestUserActivityUseCase_DeleteBookmark_SuccessOwned(t *testing.T) {
    mockProgressRepo := mocks.NewMockPlaybackProgressRepository(t)
    mockBookmarkRepo := mocks.NewMockBookmarkRepository(t)
    mockTrackRepo := mocks.NewMockAudioTrackRepository(t)
    logger := newTestLogger()
    uc := usecase.NewUserActivityUseCase(mockProgressRepo, mockBookmarkRepo, mockTrackRepo, logger)

    userID := domain.NewUserID()    // The user performing the action
    bookmarkID := domain.NewBookmarkID()
    trackID := domain.NewTrackID()

    // The bookmark to be deleted, owned by the current user
    ownedBookmark := &domain.Bookmark{
        ID:        bookmarkID,
        UserID:    userID, // Belongs to the user
        TrackID:   trackID,
        Timestamp: 10 * time.Second,
    }

    // Expect FindByID to find the owned bookmark
    mockBookmarkRepo.On("FindByID", mock.Anything, bookmarkID).Return(ownedBookmark, nil).Once()
    // Expect Delete to be called with the correct ID
    mockBookmarkRepo.On("Delete", mock.Anything, bookmarkID).Return(nil).Once()

    // Execute
    err := uc.DeleteBookmark(context.Background(), userID, bookmarkID)

    // Assert
    require.NoError(t, err)
    mockBookmarkRepo.AssertExpectations(t)
}

func TestUserActivityUseCase_DeleteBookmark_PermissionDenied(t *testing.T) {
    mockProgressRepo := mocks.NewMockPlaybackProgressRepository(t)
    mockBookmarkRepo := mocks.NewMockBookmarkRepository(t)
    mockTrackRepo := mocks.NewMockAudioTrackRepository(t)
    logger := newTestLogger()
    uc := usecase.NewUserActivityUseCase(mockProgressRepo, mockBookmarkRepo, mockTrackRepo, logger)

    requestingUserID := domain.NewUserID() // The user trying to delete
    ownerUserID := domain.NewUserID()      // The actual owner (different)
    bookmarkID := domain.NewBookmarkID()
    trackID := domain.NewTrackID()

    // Bookmark owned by someone else
    otherUsersBookmark := &domain.Bookmark{
        ID:        bookmarkID,
        UserID:    ownerUserID, // Belongs to a different user
        TrackID:   trackID,
        Timestamp: 10 * time.Second,
    }

    // Expect FindByID to find the bookmark
    mockBookmarkRepo.On("FindByID", mock.Anything, bookmarkID).Return(otherUsersBookmark, nil).Once()

    // Execute
    err := uc.DeleteBookmark(context.Background(), requestingUserID, bookmarkID)

    // Assert
    require.Error(t, err)
    assert.ErrorIs(t, err, domain.ErrPermissionDenied) // Expect permission denied

    mockBookmarkRepo.AssertExpectations(t) // FindByID was called
    // Ensure Delete was NOT called
    mockBookmarkRepo.AssertNotCalled(t, "Delete", mock.Anything, mock.Anything)
}

// TODO: Add tests for ListBookmarks (with and without track filter)
// TODO: Add tests for GetPlaybackProgress, ListUserProgress